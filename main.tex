%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Started by Víctor Araya Sánchez 
%          & Javier Salazar Loyola
%
% Based on the idea of MatPlotLib and Random Cheat
% Sheet, by Michelle Cristina de Sousa Baltazar
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[10pt]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[landscape, letterpaper, vscale=0.95, hscale=0.98]{geometry}

\usepackage{multicol}
\usepackage{multirow}
\usepackage{array}
% Columna para código
\newcolumntype{C}{>{\texttt\bgroup}l<{\egroup}}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{graphicx}

% Esto hay que arreglarlo
\usepackage{formats}

% Falta entregar el formato para esto
\usepackage{listings}
\usepackage{textcomp}

% Para subrayar al enfatizar
\usepackage{ulem}

% Colores de IDLE sacados de la definición de drivers del paquete listings
\definecolor{purple2}{RGB}{153,0,153}
\definecolor{green2}{RGB}{0,153,0}
\lstdefinestyle{python-idle-code}{%
    language=[Python3]{Python},
    basicstyle=\small\ttfamily,
    % Color settings to match IDLE style
    keywordstyle=\color{orange},
    keywordstyle={[2]\color{purple2}},
    stringstyle=\color{green2},
    commentstyle=\color{red},
    upquote=true,
}

\lstset{
    style=python-idle-code,
    tabsize=4,
    extendedchars=\true,
	inputencoding=utf8,
	literate={á}{{\'a}}1
	 {é}{{\'e}}1
	 {í}{{\'i}}1 
	 {ó}{{\'o}}1
	 {ú}{{\'u}}1
	 {ñ}{{\~n}}1
	 {ò}{{\`o}}1,
}

% Placeholders
\usepackage{mwe}

\title{Referencia Rápida de Python}
\author{FPI/FCyP}
% Reemplazar aquí con el logo que corresponda
\titlegraphic{\includegraphics[width=0.2\linewidth]{IMG/logo-fing.png}}

\usepackage[pdftex]{hyperref}
\hypersetup{
    pdftitle = {Referencia Rápida de Python},
    pdfauthor = {Víctor Araya Sánchez, Javier Salazar Loyola},
    pdfkeywords = {Python, Python 3},
}

\parindent0pt
\parskip2pt

\begin{document}
% Cosas que incluir (* los ya hechos):
% * Tipos de datos
% * Funciones básicas
% * Operaciones aritméticas (presentadas en orden de precedencia)
% - Operaciones lógicas (comparadores, booleanas)
% - Condicionales
% - Ciclos
% - Operaciones de listas

\maketitle
\begin{multicols*}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FUNDAMENTOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{contentbox}{label=Tipos Básicos}
    \centering
    \begin{tabular}{C|l|C}
        int & Números enteros & 42\\
        float & Números flotantes & 1.618\\
        bool & Valores lógicos & True \\
        str & Strings & \lstinline!"Monty"! \\
        list & Listas & [1, 2, 3]
    \end{tabular}
\end{contentbox}

\begin{contentbox}{label=Operaciones Básicas}
    \begin{tabular}{C|p{0.5\linewidth}}
        \lstinline!input("Mensaje")! & Muestra \lstinline!Mensaje! y recibe entrada por teclado del usuario\\
        \lstinline!print(valor,...)! & Muestra por pantalla los \lstinline!valores! separados por coma \\
        \lstinline!x = y! & Asignación, \lstinline!x! toma el valor de la expresión \lstinline!y!
    \end{tabular}
\end{contentbox}

\begin{contentbox}{label=Operadores Aritméticos}
    A igual nivel de precedencia (P) en las operaciones, se agrupan de a pares de izquierda a derecha.

    \begin{center}
        \begin{tabular}{C|l|c|c}
            \textnormal{Ejemplo} & Operación & P & T\footnote{Tipo}\\
            \hline
            \lstinline!x ** y! & Exponenciación\footnote{Se agrupan de derecha a izquierda.} & 1 & B \\
            \hline
            \lstinline!+ x! & Identidad & 2 & U \\
            \lstinline!- x! & Cambio de signo & 2 & U \\
            \hline
            \lstinline!x * y! & Multiplicación & 3 & B\\
            \lstinline!x / y! & División & 3 & B \\
            \lstinline!x // y! & División entera & 3 & B \\
            \lstinline!x % y! & Módulo (resto\footnote{De la división entera.}) & 3 & B \\
            \hline 
            \lstinline!x + y! & Suma & 4 & B \\
            \lstinline!x - y! & Resta & 4 & B \\
            \hline
        \end{tabular}
    \end{center}
    
    Los operadores \alert{unarios} (U) toman solo un operando. Los operadores \alert{binarios} (B) toman dos.
    
    Todos los operadores aritméticos binarios tienen una versión de asignación como \lstinline!+=!, que se usa como en el ejemplo:
    \begin{center}
        \lstinline!x += y! se interpreta como \lstinline!x = x + y!
    \end{center}
\end{contentbox}

\begin{contentbox}{label=Operadores lógicos}
    A igual nivel de precedencia en las operaciones, se agrupan de a pares de izquierda a derecha.

    \begin{center}
        \begin{tabular}{C|l|c|c}
            \textnormal{Ejemplo} & Operación & P & T \\
            \hline
            \lstinline!x > y! & Mayor que & 5 & B \\
            \lstinline!x >= y! & Mayor o igual que & 5 & B \\
            \lstinline!x < y! & Menor que & 5 & B \\
            \lstinline!x <= y! & Menor o igual que & 5 & B \\
            \lstinline!x == y! & Igual que & 5 & B \\
            \lstinline+x != y+ & Distinto que & 5 & B \\
            \lstinline!x in l! & Pertenece a & 5 & B \\
            \lstinline!x not in l! & No pertenece a & 5 & B \\
            \hline
            \lstinline!not p! & Negación & 6 & U \\
            \lstinline!p and q! & Y lógico & 7 & B \\
            \lstinline!p or q! & O lógico & 8 & B \\
            \hline
        \end{tabular}
    \end{center}
\end{contentbox}

\begin{contentbox}{label=Decisiones con \texttt{if}}
    Ejecutar sentencias que solo deben ocurrir al cumplirse la \lstinline!<condición>! (\alert{expresión booleana}):
\begin{lstlisting}
if <condición>:
    <sentencias condicionadas>
\end{lstlisting}

    Ejecutar sentencias que solo deben ocurrir al cumplirse una condición, y otras en caso que no:
\begin{lstlisting}
if <condición>:
    <sentencias condicionadas>
else:
    <sentencias alternativas>
\end{lstlisting}

    Ejecutar sentencias que solo deben ocurrir al cumplirse una condición, otras en caso de que no se cumpla la primera condición, pero si una segunda condición\footnote{Tantas condiciones secundarias (\lstinline!elif!) como se necesite.}, y otras en caso de que no se cumpla la primera ni la segunda:
\begin{lstlisting}
if <condición 1>:
    <sentencias condicionadas 1>
elif <condición 2>:
    <sentencias condicionadas 2>
else:
    <sentencias alternativas>
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Bloques de decisiones}
    Cada secuencia \lstinline!if!, \lstinline!if-else! o \lstinline!if-elif-else! es un bloque independiente.
    
    Dentro de un mismo bloque se ejecutarán las sentencias condicionadas a la primera condición válida comprobada.
    
    Si existieran 2 bloques de decisión consecutivos se ejecutarán las sentencias condicionadas a la primera condición válida para cada bloque de manera independiente.
\end{contentbox}

\begin{contentbox}{label=Ciclos con \texttt{while}}
    Realizar una repetición condicionada de sentencias: 
\begin{lstlisting}
while <condición>:
    <sentencias_a_repetir>
\end{lstlisting}

    Donde \lstinline!condición! es una \alert{expresión booleana} y \lstinline!<sentencias_a_repetir>! (última instrucción indentada con respecto a \lstinline!while!) es la secuencia de instrucciones a repetir.
    
    A través de este bloque, se asegura la ejecución de las \lstinline!<sentencias_a_repetir>! mientras se cumpla la \lstinline!condición! señalada.
    
    Se puede repetir cualquier sentencia, incluyendo otros ciclos.
\end{contentbox}

\begin{contentbox}{label=Banderas (\textit{Flags})}
    Parte de la \lstinline!<condición>! puede ser una variable booleana: esta indica si se debe continuar o no, según qué ocurra en el ciclo:
    
\begin{lstlisting}
i = 1
keep_going = True
while keep_going and i <= 5:
    if i % 2 == 0:
        keep_going = False
    i += 1
\end{lstlisting}

    Haciendo uso de decisiones (\lstinline!if!) y de una bandera (\lstinline!keep_going!), se puede verificar si se cumple una condición adicional bajo la cual detener el ciclo antes de que el iterador \lstinline!i! llegue a su límite.
\end{contentbox}

\begin{contentbox}{label=Listas}
    \begin{tabular}{C|p{0.5\linewidth}}
        \lstinline!lista = [1, 2, 3]! & Define un objeto de tipo lista. \\
        \lstinline!lista[i]! & Retorna el elemento en la posición \lstinline!i!. Soporta de \lstinline!0! a \lstinline!n-1!\footnote{Con \lstinline!n! equivalente al largo de la lista.} de izquierda a derecha y de \lstinline!-1! a \lstinline!-n! de derecha a izquierda. \\
        \lstinline!lista.append(4)! & Añade el elemento \lstinline!4! al final de la lista. \\
        \lstinline!lista[j] = z! & Redefine el valor del elemento en la posición \lstinline!j! de la lista a \lstinline!z!. \\
        \lstinline!lista.pop(k)! & Retorna el elemento en la posición \lstinline!k! y lo elimina de \lstinline!lista!. Sin parámetros retorna y elimina el último elemento. \\
        \lstinline!lista.count(c)! & Retorna la cantidad de apariciones del elemento \lstinline!c!. \\
        \lstinline!lista.index(d)! & Retorna la posición del elemento \lstinline!d!. \\
        \lstinline!lista.remove(e)! & Elimina la primera aparición del elemento \lstinline!e!. \\
        \lstinline!lista.insert(i, f)! & Inserta el elemento \lstinline!f! en la posición \lstinline!i!\footnote{Los elementos siguientes son desplazados en 1 posición a la derecha.}. \\
        \lstinline!lista.sort()! & Ordena \lstinline!lista! en orden creciente. \\
        \lstinline!lista1 + lista2! & Retorna una lista que concatena \lstinline!lista1! y \lstinline!lista2!. \\
        \lstinline!lista * n! & Retorna una lista que concatena \lstinline!lista! \lstinline!n! veces\footnote{\lstinline!n! debe ser entero.}. \\
    \end{tabular}
\end{contentbox}

% \begin{contentbox}{label=Largo de una Lista}
%     El largo de la lista \lstinline!lista! se obtiene mediante la función nativa \lstinline!len(lista)!. Se entiende por ``largo'' el total de elementos que hay en esta.
    
%     Si una lista tiene como elemento otra lista, este elemento sigue contando como uno solo.
% \end{contentbox}

\begin{contentbox}{label=Largo de una Secuencia}
    El largo de la secuencia \lstinline!seq! se obtiene mediante la función nativa \lstinline!len(seq)!. Se entiende por ``largo'' de una secuencia como el total de elementos que hay en esta.
    
    En el caso de una lista, si tiene como elemento otra lista, este elemento sigue contando como uno solo.
\end{contentbox}

\begin{contentbox}{label=Cortes y Copias}
    Pueden accederse \alert{cortes} de una secuencia como una lista o string mediante la \alert{notación slice}. Su notación básica es
    \begin{center}
        \lstinline!objeto[a:b:c]!,
    \end{center}
    retornando un objeto del mismo tipo del seccionado, con \lstinline!a! el índice inicial del corte, \lstinline!b! el índice final (él último índice retornado será siempre el mayor valor posible menor a \lstinline!b!) y \lstinline!c! la distancia entre dos elementos consecutivos recuperados. \lstinline!a! y \lstinline!b! deben ser índices válidos y \lstinline!c! debe ser un número entero (positivo o negativo).
    
    Esta notación tiene las siguientes variaciones:
    \begin{itemize}
        \item Si se omite \lstinline!a! (pero no \lstinline!:!), inicia desde el comienzo.
        \item Si se omite \lstinline!b! (pero no \lstinline!:!), llega hasta el final.
        \item Si se omite \lstinline!c! (incluyendo o no \lstinline!:!), se asume 1.
    \end{itemize}
\end{contentbox}

\begin{contentbox}{label=Consultas sobre Strings}
    Todos estos métodos devuelven \texttt{True} o \texttt{False}.
    
    \begin{tabular}{C|p{0.5\linewidth}}
        \lstinline!s.isupper()! & Todas las letras son mayúsculas y hay al menos una. \\
        \lstinline!s.islower()! & Todas las letras son minúsculas y hay al menos una. \\
        \lstinline!s.isalpha()! & Todos los caracteres son alfabéticos. \\
        \lstinline!s.isdigit()! & Todos los caracteres son dígitos. \\
        \lstinline!s.isalnum()! & Todos los caracteres son alfabéticos o dígitos. \\
        \lstinline!s.endswith(t)! & El string termina con \texttt{t}. \\
        \lstinline!s.startswith(t)! & El string empieza con \texttt{t}.
    \end{tabular}
\end{contentbox}

\begin{contentbox}{label=String a Lista y Viceversa}
    \begin{itemize}
        \item \lstinline!s.split(sep)! separa el string utilizando \texttt{sep} como separador y retorna una lista cuyos elementos son los fragmentos del string.
        \item \lstinline!sep.join(lista)! une los elementos de \texttt{lista}, separados por \texttt{sep}, en un único string. Solo funciona si los elementos son strings.
    \end{itemize}
\end{contentbox}

\begin{contentbox}{label=Strings}
    \begin{tabular}{C|p{0.5\linewidth}}
        \lstinline!s = "Monty"! & \multirow{2}{=}{Define un objeto de tipo string.} \\
        \lstinline!s = 'Python'! \\
        \lstinline!s.find(sub)! & Retorna el índice donde empieza \texttt{sub}. \\
        \lstinline!s.rfind(sub)! & Como \texttt{find}, pero desde la derecha. \\
        \lstinline!s.index(sub)! & Como \texttt{find}, pero arroja error si no encuentra.\\
        \lstinline!s.lower()! & Retorna el string en minúscula. \\
        \lstinline!s.upper()! & Retorna el string en mayúscula. \\
        \lstinline!s.strip(t)! & Retorna el string eliminando los caracteres en \texttt{t} de los extremos del string. \\
        \lstinline!s.strip()! & Como \texttt{strip}, pero eliminando espacios en blanco. \\
        % \lstinline!s.lstrip()! & Igual a \texttt{strip}, pero solo a la izquierda. \\
        % \lstinline!s.rstrip()! & Igual a \texttt{strip}, pero solo a la derecha. \\
        % 
        \lstinline!s.capitalize()! & Retorna el string convertido con el primer caracter a mayúscula, si es una letra, y el resto a minúscula. \\
        \lstinline!s.title()! & Retorna el string en ``Formato De Título''. \\
        \lstinline!s.count(sub)! & Retorna la cantidad de apariciones no superpuestas de \texttt{sub}.
    \end{tabular}
\end{contentbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FUNCIONES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{contentbox}{label=Funciones Nativas}
    %Además de \lstinline!print! e \lstinline!input!, las siguientes funciones, entre otras, están siempre disponibles:
    Estas funciones, entre otras, están siempre disponibles:
    
    \begin{tabular}{C|p{0.5\linewidth}}
        \lstinline!abs(x)! & Valor absoluto de \texttt{x}. \\
        \lstinline!max(seq)! & Retorna el máximo de \texttt{seq}. \\
        \lstinline!min(seq)! & Retorna el mínimo de \texttt{seq}.\\
        \lstinline!range(stop)! & \multirow{2}{=}{Genera una secuencia de valores enteros.} \\
        \lstinline!range(i, f, s)! & \\
        \lstinline!round(x)! & \multirow{2}{=}{Redondea \texttt{x} a entero o a \texttt{n} decimales.} \\
        \lstinline!round(x, n)! & \\
        \lstinline!sorted(seq)! & Retorna la secuencia \texttt{seq} ordenada \\
        \lstinline!type(o)! & Retorna el tipo de \texttt{o} \\
        \lstinline!isinstance(o, c)! & Verifica si \texttt{o} es del tipo \texttt{c} \\
    \end{tabular}
    
    El nombre de cada tipo de dato es la función para cambiar a dicho tipo de dato, p.e.: \lstinline!x = int(y)! o \lstinline!l = list(s)! (si \texttt{s} es un conjunto o secuencia, como un string).
\end{contentbox}

\begin{contentbox}{label=Funciones Importadas}
    Un módulo es un archivo que contiene definiciones y declaraciones en Python.
    
    Existen módulos estándar (siempre disponibles para importar), definidos por el programador y externos (instalados en el sistema).
    
    Para importar, utilizamos:
    \begin{lstlisting}
import module
# Uso de, por ejemplo, func1:
module.func1(params)
# Alternativamente, podemos dar un 
# alias
import module as bla
bla.func1(params)
    \end{lstlisting}
    
    En casos especiales, podemos importar solo las funciones de interés utilizando:
    \begin{center}
        \lstinline!from module import func1, func2, func3!
    \end{center}
    De modo que se pueda utilizar \verb|func1|, \verb|func2| y \verb|func3| como si fuesen nativas.
\end{contentbox}

\begin{contentbox}{label=Definición de Funciones Propias}
    La estructura básica de definición de funciones es:
\begin{lstlisting}
def func_name(arg1, arg2, arg3=valor):
    definiciones_y_operaciones_locales
    return resultado
\end{lstlisting}

    \begin{itemize}
        \item Dondequiera que se encuentre \lstinline!return!, se finaliza la función y se entrega ese resultado. Puede haber varios, según si los resultados son condicionados.
        \item Los parámetros son tantos como se requieran. Si no se requieren, los paréntesis van vacíos.
        \item Los parámetros opcionales se escriben al final, dándoles su valor por defecto (como en \verb|arg3|).%, también separándolos por coma.
    \end{itemize}

    Una vez definida, se llama como una función nativa normal:
\begin{lstlisting}
# Solo parámetros obligatorios
r = func_name(x, y)
# Con el parámetro opcional
r = func_name(x, y, z)
# Dando nombre del parámetro opcional
r = func_name(x, y, arg3=z)
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Recursión}
    Python solo requiere el nombre de la función para poder utilizarla, por lo que podemos construir una función en base a sí misma:
\begin{lstlisting}
def func(x):
    if condición(x):
        new_x = operaciones(x)
        return func(new_x)
    else:
        return otras_operaciones(x)
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Comentarios y Documentación}
    Las líneas comenzadas por \lstinline!#! son comentarios e ignorados por el intérprete. Sirven para documentar el código para quien lo lea.
    
    Las funciones se pueden documentar con \textit{docstrings}, explicando su utilidad y forma de uso inmediatamente después de definirlas:
\begin{lstlisting}
def ejemplo(arg1, arg2=valor):
    """Descripción de lo que hace la
    función
    
    Entradas: Se describen sus entradas 
    (incluyendo tipo de dato)
    Salidas: Se describen sus salidas 
    (incluyendo tipo de dato)
    """
    operaciones
    return resultado
\end{lstlisting}

    Las docstrings son un tipo de string multilínea, pueden escribirse con triple comilla simple (\lstinline!'''así'''!) o triple comilla doble (\lstinline!"""así"""!).
    
    \textbf{N.B.}: Los comentarios son para quien leerá o modificará el código, las docstrings son para quien utilizará la función en el suyo propio.
\end{contentbox}

\begin{contentbox}{label=Módulos Estándar}
    \small
    \begin{tabular}{C|p{0.7\linewidth}}
        \lstinline!math! & Funciones matemáticas. \\
        \lstinline!sys! & Funciones y parámetros del intérprete. \\
        \lstinline!op.path! & Manipulaciones de rutas de archivo. \\
        \lstinline!random! & Generación de números pseudo aleatorios. \\
        \lstinline!datetime! & Tipos básicos de fecha y hora. \\
        \lstinline!copy! & Operaciones de copia superficial y profunda. \\
        \lstinline!time! & Operaciones de tiempo. \\
    \end{tabular}
\end{contentbox}

\begin{contentbox}{label=Importación de Módulos Propios}
    Si escribimos funciones y constantes en un archivo independiente, puede importarse como cualquier otro módulo:
\begin{lstlisting}
# Si utilidades.py existe en la
# misma carpeta
import utilidades
\end{lstlisting}

Alternativamente,
\begin{lstlisting}
from utilidades import func
\end{lstlisting}
    
    Se pueden importar nombres de funciones y constantes.
    
    El nombre del módulo no puede contener espacios.
\end{contentbox}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % ARCHIVOS
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{contentbox}{label=Ciclos con \texttt{for}}
    Repite la acción por cada elemento de la secuencia:
\begin{lstlisting}
for elemento in secuencia:
    acciones_a_repetir
\end{lstlisting}
    
    La variable \lstinline!elemento! es definida en está secuencia y su valor es cada elemento de la secuencia en orden.
    
    Entre las secuencias, se incluyen (entre muchos otros) archivos, \lstinline!list!, \lstinline!str!, \lstinline!range!, etc.
\end{contentbox}

\begin{contentbox}{label=Función \lstinline!range!}
    Generación de secuencias numéricas:
    \begin{itemize}
        \item \lstinline!range(stop)! genera números de 0 a \texttt{stop-1}.
        \item \lstinline!range(start, stop, d)! genera números desde \texttt{start} hasta \texttt{stop-1}, con distancia de \texttt{d} entre ellos.
    \end{itemize}
    
%     Por ejemplo, para mostrar todos los números desde 0 a $n-1$:
% \begin{lstlisting}
% for i in range(n):
%     print(i)
% \end{lstlisting}

    Nótese que \lstinline!range! no es una lista, pero puede convertirse a una mediante \lstinline!list(range(n))!.
\end{contentbox}

\begin{contentbox}{label=Archivos}
    Un archivo es un objeto especial en Python creado con la función nativa \lstinline!open!:
    
    \begin{center}
        \lstinline!file = open(ruta, modo)!
    \end{center}
    
    El parámetro \texttt{ruta} (\lstinline!str!) especifica dónde encontrar el archivo (carpetas y nombre).
    
    Cuando dejamos de usar el archivo, debemos cerrarlo, para lo que se utiliza el método \lstinline!close!, como en \lstinline!file.close()!.
\end{contentbox}
    
\begin{contentbox}{label=Parámetros de archivo}
    Pueden darse tres modos de apertura:
    
    \begin{center}
        \begin{tabular}{C|p{0.5\textwidth}}
            \textnormal{Opción} & Modo \\
            \hline
            r & Lectura \\
            w & Escritura \\
            a & Añadir
        \end{tabular}
    \end{center}
    
    Si la codificación del archivo no es la del sistema, se puede especificar con \lstinline!encoding!:
    \begin{lstlisting}
file = open(ruta, modo,
            encoding="utf8")
    \end{lstlisting}
    
    Las principales codificaciones aquí son \lstinline!utf8! y \lstinline!latin1!.
\end{contentbox}
    
\begin{contentbox}{label=Operación \lstinline!with!}
    Podemos utilizar un administrador de contexto para trabajar con archivos, a través del bloque \lstinline!with ... as...!, en cuyo caso no es necesario utilizar \lstinline!close!:
    \begin{lstlisting}
with open(ruta, modo) as file:
    operaciones_sobre(file)
    \end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Operaciones sobre Archivos}
    Los métodos básicos de archivo son:
    
    \begin{tabular}{C|p{0.5\linewidth}}
        \lstinline!file = open(r, m)! & Abre el archivo en la ubicación \texttt{r} con modo \texttt{m}. \\
        \lstinline!file.read()! &  \multirow{2}{=}{Lee todo el archivo o hasta \texttt{n} caracteres.} \\
        \lstinline!file.read(n)! &  \\
        \lstinline!file.readline()! &  Lee como string hasta el próximo final de línea. \\
        \lstinline!file.readlines()! &  Lee como lista de strings todo el archivo. \\
        \lstinline!file.write(s)! & Escribe el string \texttt{s} en el archivo. \\
        \lstinline!file.writelines(l)! & Escribe la lista de strings \texttt{l} en el archivo. \\
        \lstinline!file.close()! & Cierra el archivo, impidiendo futuros accesos. \\
    \end{tabular}
    
    Cada lectura y escritura se hacen a partir de donde terminó la anterior. Toda lectura y escritura es \emph{literal}: no se añaden ni quitan caracteres.
    
%     Además, el archivo puede ser leído como una secuencia mediante \lstinline!for!, en cuyo caso cada elemento de la secuencia es una línea (string):
% \begin{lstlisting}
% for line in file:
%     print(line.strip("\n"))
% \end{lstlisting}
% \vspace{-12pt}
\end{contentbox}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % MÓDULO numpy
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{contentbox}{label=Módulos externos}
    Se pueden instalar módulos utilizando \lstinline!pip! en la terminal del sistema:
\begin{lstlisting}[language=bash]
pip install módulo
\end{lstlisting}

    Algunos módulos importantes:
    
    \begin{tabular}{C|p{0.6\linewidth}}
        \lstinline!numpy! & Arreglos multidimensionales y computación científica. \\
        \lstinline!matplotlib! & Visualizaciones y gráficos.
    \end{tabular}
    
    Una vez instalados, se importan como cualquier otro módulo:
\begin{lstlisting}
import numpy as np
\end{lstlisting}
    Las próximas secciones asumirán que \lstinline!numpy! ha sido importado de esta manera.
\end{contentbox}

\begin{contentbox}{label=Arreglos en \lstinline!numpy!}
    Se puede transformar una secuencia (o secuencia de secuencias) mediante la función:
\begin{lstlisting}
a = np.array(secuencia)
\end{lstlisting}
    
    Todos los elementos del arreglo son del mismo tipo. El parámetro opcional \lstinline!dtype! permite especificar el tipo de dato (e.g. , \lstinline!dtype=float! para un arreglo de flotantes).
    
    El tipo de dato del arreglo es \lstinline!np.ndarray! y es mutable (soporta asignación de elementos).
\end{contentbox}

\begin{contentbox}{label=Operaciones de arreglo}
    Siendo \lstinline!u! un arreglo,
    
    \begin{tabular}{C|p{0.6\linewidth}}
        \lstinline!u[i]! & Posición \lstinline!i!. \\
        \lstinline!u[i, j]! & Posición en fila \lstinline!i! y columna \lstinline!j! \\
        \lstinline!u.shape! & Tupla con las dimensiones. \\
        \lstinline!len(u)! & Tamaño de primera dimensión de \lstinline!u!. \\
        \lstinline!u.flat! & Iterador undimensional con todos los elementos. \\
        \lstinline!u.flatten()! & Copia unidimensional del arreglo.
    \end{tabular}
    
    Para acceder a los elementos, tanto \lstinline!i! como \lstinline!j! pueden ser cortes (\textit{slices})
\end{contentbox}

\begin{contentbox}{label=Operaciones vectoriales}
    Todos los operadores aritméticos básicos y de comparación se aplican elemento a elemento en arreglos del mismo tamaño, p.e.:
\begin{lstlisting}
w = u + v
\end{lstlisting}
    Aplica la suma a cada par de elementos. Similarmente, si \lstinline!a! es un escalar,
\begin{lstlisting}
v = a + u
\end{lstlisting}
    suma su valor a todos los elementos de \lstinline!u!.
    
    Para las operaciones lógicas vectoriales, existen los siguientes operadores:
    
    \begin{tabular}{C|p{0.6\linewidth}}
        \lstinline!~u! & Negación por elementos. \\
        \lstinline!u & v! & Y lógico elemento a elemento. \\
        \lstinline!u | v! & O lógico elemento a elemento. \\
        \lstinline!u ^ v! & O excluyente elemento a elemento. \\
    \end{tabular}
    
    Estas operaciones tienen la misma precedencia que un comparador.
\end{contentbox}

\begin{contentbox}{label=Funciones vectoriales}
    Las siguientes funciones son versiones para aplicar sobre todos los elementos de un array:
    
    \begin{tabular}{C|p{0.4\linewidth}}
        \lstinline!np.sin(u)! & Seno. \\
        \lstinline!np.cos(u)! & Coseno. \\
        \lstinline!np.exp(u)! & Exponencial. \\
        \lstinline!np.log(u)! & Logaritmo. \\
        \lstinline!np.logical_not(u)! & \lstinline!~u! \\
        \lstinline!np.logical_and(u, v)! & \lstinline!u & v! \\
        \lstinline!np.logical_or(u, v)! & \lstinline!u | v! \\
        \lstinline!np.logical_xor(u, v)! & \lstinline!u ^ v! \\
        \lstinline!np.all(u)! & \lstinline!True! si todos lo son. \\
        \lstinline!np.any(u)! & \lstinline!True! si alguno lo es. \\
    \end{tabular}
    
\end{contentbox}

\begin{contentbox}{label=Generadores}
    Las siguientes funciones generan arreglos siguiendo diferentes patrones:
    
    \begin{tabular}{C|p{0.45\linewidth}}
        \small
        \lstinline!np.arange(n)! & \multirow{2}{=}{Arreglo como \lstinline!range!.} \\
        \lstinline!np.arange(a, b, c)! & \\
        \lstinline!np.linspace(a, b, c)! & \texttt{c} puntos desde \texttt{a} hasta \texttt{b}. \\
        \lstinline!np.zeros(n)! & Arreglo de 0 de tamaño \texttt{n}. \\
        \lstinline!np.ones(n)! & Arreglo de 1 de tamaño \texttt{n}. \\
    \end{tabular}
\end{contentbox}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % MÓDULO Matplotlib
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{contentbox}{label=Módulo Matplotlib}
    El módulo Matplotlib permite visualizar y crear gráficos a través de su interfaz \texttt{pyplot}:
    
\begin{lstlisting}
import matplotlib.pyplot as plt
\end{lstlisting}

    Las funciones principales se obtienen a partir de este submódulo. Tras generar los gráficos, estos se visualizan usando:
\begin{lstlisting}
plt.show()
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Gráfico de línea}
    Se crean gráficos de líneas con \lstinline!plt.plot!. Su parámetro son arreglos o equivalentes con valores numéricos:
    
\begin{lstlisting}
# Gráfico de y versus sus índices
g = plt.plot(y)
# Gráfico de y versus x
g = plt.plot(x, y)
# Gráfico de y versus x rojo
g = plt.plot(x, y, 'r')
\end{lstlisting}
    
    Retorna una lista de gráficos.
    
    Pueden graficarse varias líneas agrupando dos o tres parámetros: eje $x$, eje $y$, formato (opcional):
\begin{lstlisting}
g = plt.plot(x_1, y, x_1, z, x_2, f)
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Estilo de las líneas}
    El estilo del gráfico se controla mediante la función \lstinline!plt.setp! y sus parámetros:
\begin{lstlisting}
plt.setp(g, param_1=valor,
         param_2=valor,...)
\end{lstlisting}
    El parámetro \lstinline!g! es un gráfico o lista de gráficos. El resto de parámetros incluye:
    
    \begin{tabular}{C|p{0.5\textwidth}}
        color & Color de la línea. \\
        marker & Tipo de marcador. \\
        markersize & Tamaño de marcador en puntos. \\
        linestyle & Tipo de línea. \\
        linewidth & Ancho de línea en puntos.
    \end{tabular}

\end{contentbox}

\begin{contentbox}{label=Gráfico Circular}
    Se genera con \lstinline!plt.pie! y requiere un vector o lista con valores. Genera una ``torta'' de radio 1. Sus parámetros incluyen:

    \begin{tabular}{C|p{0.5\textwidth}}
        autopct & \lstinline!str! para etiquetar las porciones con su valor. \\
        labels & Secuencia de etiquetas. \\
        explode & Secuencia con distancia del centro para cada porción. \\
        labeldistance & Distancia de la etiqueta. \\
        rotatelabels & Para \lstinline!True!, rota las etiquetas para cada porción.
    \end{tabular}
    
    Ejemplo:
\begin{lstlisting}
valores = [0, 2, 1, 3]
etiquetas = ["a", "b", "c", "d"]
plt.pie(valores, labels=etiquetas,
        autopct="%1.f%%")
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Histograma}
    Muestra frecuencia de ocurrencia de valores en contenedores (\textit{bins}). Su parámetro \lstinline!bins! es cuántos contenedores hay o una secuencia que los especifique:
    
\begin{lstlisting}
dados = np.random.randint(1, 10, 10000)
plt.hist(dados, bins=5)
\end{lstlisting}

\end{contentbox}

\begin{contentbox}{label=Gráfico de Barras}
    Un gráfico de barras se construye igual que el de líneas, pero solo uno a la vez. Sus parámetros principales son posición y alto de cada barra:
\begin{lstlisting}
plt.bar(np.arange(len(valores)),
        valores, width=0.8,
        align='center')
\end{lstlisting}

    Los valores por defecto de los parámetros son los dados.
    
    Para un gráfico de barras horizontal, se usa \lstinline!plt.barh! y se intercambian los parámetros height y width:
\begin{lstlisting}
plt.barh(np.arange(len(valores)),
         valores, height=0.8,
         align='center')
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Etiquetas del gráfico}
\begin{lstlisting}
plt.title("Título del gráfico")
plt.xlabel("Eje $x$")
plt.ylabel("Eje $y$")
# Posiciones y etiquetas deben
# ser del mismo largo
# Etiquetas pueden ser strings
plt.xticks(posiciones_x, etiquetas_x)
plt.yticks(posiciones_y, etiquetas_y)
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Leyenda}
    Las leyendas se incluyen a partir de las etiquetas de cada gráfico (parámetro opcional \lstinline!label!) o directamente con \lstinline!plt.legend!.
    
\begin{lstlisting}
# Genera leyenda a partir de etiquetas
# previas
plt.legend()
# Explícitamente se dan las leyendas
# (en orden de creación)
plt.legend(["a", "b", "c"])
# Asignando explícitamente a cada uno
plt.legend(g, "a")
\end{lstlisting}
\end{contentbox}

\begin{contentbox}{label=Múltiples gráficos}
\begin{lstlisting}
# Crea y selecciona figura en blanco
fig = plt.figure()
# Selecciona figura n
fig = plt.figure(n)
# Selecciona el subgráfico i
# al subdividir la figura en n por m
plt.subplot(n, m, i)
\end{lstlisting}
    Se crean los gráficos en la última figura seleccionada.
\begin{lstlisting}
# Crea figura y un eje para graficar
fig, ax = plt.subplots()
ax.plot(x, y)
# Crea figura y arreglo de n ejes
# para graficar
fig, ax = plt.subplots(n)
ax[0].plot(x, y)
# Crea figura y matriz de
# n por m de ejes
fig, ax = plt.subplots(n, m)
ax[0, 0].plot(x, y)
\end{lstlisting}
\end{contentbox}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % MÓDULO pandas
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{contentbox}{label=Objetos Básicos de Pandas}
%     La importación tradicional de \texttt{pandas} es
%     \begin{center}
%         \lstinline!import pandas as pd!
%     \end{center}
    
%     Un \texttt{DataFrame} es una tabla con índices \alert{ordenados} para filas y columnas. Pueden ser numerados (por defecto, posiciones de listas) o nombrados (números, strings). En ambos casos sirven como \textbf{claves}. Se crean con:
    
%     \begin{lstlisting}
% df = pd.DataFrame(datos, index=filas, 
%                   columns=columnas,
%                   dtype=tipos)
%     \end{lstlisting}
    
%     con los parámetros:
%     \begin{description}
%     \item[\texttt{datos}] matriz con los elementos de la tabla. Para listas de listas cada lista es una fila y cada elemento de ella una nueva columna.
%     \item[\texttt{index}] lista con nombres de filas.
%     \item[\texttt{columns}] lista con nombres de columnas.
%     \item[\texttt{dtype}] Tipo de dato de las columnas
%     \end{description}
% \vspace{-13pt}
% \end{contentbox}

% \begin{contentbox}{label=DataFrame a partir de \textsc{csv}}
%     \begin{lstlisting}
% Tabla = pd.read_csv("ruta/fichero.csv",
%                     sep=",",
%                     header=n,
%                     index_col=m,
%                     decimal=".")
%     \end{lstlisting}
    
%     con los parámetros:
%     \begin{description}
%     \item[\texttt{sep}] - separador de columnas (por defecto \lstinline!","!).
%     \item[\texttt{header}] -  número de fila del encabezado (nombres de columnas).
%     \item[\texttt{index\_col}] - número de la columna con los índices de fila.
%     \item[\texttt{decimal}] - Indicador de parte decimal (por defecto, \lstinline!"."!).
%     \end{description}
    
%     Otros parámetros:
%     \begin{description}
%     \item[\texttt{names}] Lista de nombres de columnas.
%     \item[\texttt{usecols}] Lista de nombres de columnas a usar.
%     \item[\texttt{dtype}] Diccionario de columnas y tipos.
%     \end{description}
% \end{contentbox}

% \begin{contentbox}{label=DataFrame a partir de Hoja de Cálculo}
%     \begin{lstlisting}
% Tabla = pd.read_excel("ruta/fichero",
%                       sheet_name=sheet)
%     \end{lstlisting}
    
%     Se usa \lstinline!sheet_name! para especificar el nombre o número de la hoja a cargar. Si no se hace, se carga la primera.
    
%     Todos los parámetros mencionados de \lstinline!pd.read_csv! tienen el mismo significado, salvo \texttt{delimiter} y \texttt{decimal}, que no existen en esta función.
% \end{contentbox}

% \begin{contentbox}{label=Información de DataFrame}
%     \begin{tabular}{C|p{0.65\linewidth}}
%         \lstinline!df.info()! & Resumen informativo. \\
%         \lstinline!df.head(n)! &  Primeras \texttt{n} líneas. \\
%         \lstinline!df.tail(n)! &  Últimas \texttt{n} líneas. \\
%         \lstinline!df.shape! & Tupla con las dimensiones en la forma \lstinline!(filas, columnas)!. \\
%         \lstinline!df.columns! &  Iterable con nombres de columnas. \\
%         \lstinline!df.index! &  Iterable con nombres de filas.
%     \end{tabular}
% \end{contentbox}

% \begin{contentbox}{label=Acceso a un DataFrame}
%     \begin{tabular}{C|p{0.55\linewidth}}
%         \lstinline!df[col]! & Acceso a la columna \texttt{col}. \\
%         \lstinline!df[l_cols]! & Acceso a las columnas \lstinline!l_cols! (lista de columnas). \\
%         \lstinline!df[col][row]! &  Acceso al elemento en la columna \texttt{col} y la fila \texttt{row}. \\
%         \lstinline!df.loc[row]! & Acceso a la fila \texttt{row}. \\
%         \lstinline!df.loc[l_rows]! & Acceso a las filas \lstinline!l_rows! (lista de filas). \\
%         \lstinline!df.loc[row, col]! &  Acceso al elemento en la fila \texttt{row} y la columna \texttt{row}. \\
%         \lstinline!l_cols!. \\
%         \lstinline!df.iloc[n]! &  Acceso a la fila \texttt{n}. \\
%         \lstinline!df.iloc[n, m]! &  Acceso al elemento en la fila \texttt{n} y columna \texttt{m}. \\
%     \end{tabular}
    
%     Cuando accedemos a solo una fila o una columna, obtenemos una \lstinline!pd.Series!, una ``lista'' cuyos índices son las filas del \texttt{DataFrame}.
    
%     La diferencia entre \texttt{iloc} y \texttt{loc} es que la primera funciona con las posiciones como enteros (equivalente a listas), mientras que la segunda, con los \alert{nombres} de las filas y columnas.
    
%     Al acceder a un dato, fila o columna es posible cambiar su valor haciendo la asignación respectiva (equivalente a listas).
% \end{contentbox}

% \begin{contentbox}{label=Segmentos en \texttt{DataFrame}}
%     La nomenclatura de segmentos puede ser utilizada en todos los mecanismos de acceso a un \texttt{DataFrame}, en cualquiera de sus dimensiones:
    
%     \begin{tabular}{C|p{0.5\linewidth}}
%         \lstinline!df.iloc[a:b:c]! &  Segmento de la fila \texttt{a} a \texttt{b}, sin incluirla, cada \texttt{c} filas. \\
%         \lstinline!df.iloc[n, :b]! &  Fila \texttt{n} hasta la columna anterior a \texttt{b}. \\
%         \lstinline!df.iloc[a:, m]! &  Desde la fila \texttt{a}, la columna \texttt{m}. \\
%         \lstinline!df.iloc[a:b, c:]! &  Filas \texttt{a} hasta \texttt{b}, sin incluirla, y desde la columna \texttt{c}.
%     \end{tabular}
    
%     A diferencia de las posiciones enteras accedidas con \lstinline!iloc!, al utilizar los nombres de filas y columnas (con \lstinline!loc! o el operador \lstinline![]!), la columna de término sí es accedida:
    
%     \begin{tabular}{C|p{0.5\linewidth}}
%         \lstinline!df["c_1":"c_2"]! &  Desde la columna \lstinline!c_1! hasta \lstinline!c_2!. \\
%         \lstinline!df["c_1":"c_2":2]! &  Desde la columna \lstinline!c_1! hasta \lstinline!c_2! cada dos. \\
%         \lstinline!df.loc["r_1":"r_2]! &  Desde la fila \lstinline!r_1! hasta \lstinline!r_2!. \\
%     \end{tabular}
% \end{contentbox}

% \begin{contentbox}{label=Operaciones Vectoriales}
%     Las operaciones aritméticas básicas de Python son \alert{vectoriales} en \texttt{pandas}. Esto significa que, al operar dos \texttt{DataFrame} o \texttt{Series} del mismo tamaño, se operan elemento a elemento:
%     \begin{lstlisting}
% sumas = df["col_1"] + df["col_2"]
%     \end{lstlisting}
    
%     Si se operan con un escalar, este se opera sobre todos los elementos del \texttt{DataFrame} o \texttt{Series}.
%     \begin{lstlisting}
% amplificada = 10*df["col_1"]
%     \end{lstlisting}
    
%     En el caso de operaciones de comparación, resultan en un \texttt{DataFrame} o \texttt{Series} de \alert{booleanos}:
%     \begin{lstlisting}
% filtro = df["col_3"] > df["col_4"]
%     \end{lstlisting}
    
% \end{contentbox}

% \begin{contentbox}{label=Operaciones Lógicas Vectoriales}
%     \begin{tabular}{C|p{0.35\linewidth}}
%         \lstinline!df["col_1"] & df["col_2"]! & Y lógico vectorial. \\
%         \lstinline!df["col_1"] | df["col_2"]! &  O lógico vectorial. \\
%         \lstinline!~df["col"]! &  No lógico vectorial. \\
%         \lstinline!df["col_1"]^df["col_2"]! & O lógico excluyente vectorial.
%     \end{tabular}
    
%     Todas estas operaciones evalúan el operador elemento a elemento en las columnas.
% \end{contentbox}

% \begin{contentbox}{label=Filtrado en \texttt{pandas}}
%     Alternativamente a los métodos habituales de acceso, una \texttt{Series} o \texttt{DataFrame} de booleanos puede ser válida como índice. Hacer esto genera un subconjunto de los elementos originales que contiene solo los elementos cuya posición está marcada como \lstinline!True!.
    
%     Podemos usar operadores booleanos vectoriales para filtrar los datos:
%     \begin{lstlisting}
% # Subconjunto con los valores en 
% # "col_3" entre 2 y 5
% df[df["col_3"] > 2 & df["col_3"] < 5]
%     \end{lstlisting}

%     El resultado es un nuevo \texttt{DataFrame}.
    
%     Otras operaciones booleanas (i.e. válidas como filtro) incluyen:
    
%     \begin{tabular}{C|p{0.35\linewidth}}
%         \lstinline!df.isin(a, b)! & Si las ubicaciones están entre \texttt{a} y \texttt{b} \\
%         \lstinline!df.isna()! &  Posiciones con valores nulos o vacíos \\
%         \lstinline!df.notna()! &  \lstinline!~df.isna()!. \\
%     \end{tabular}
% \end{contentbox}

% \begin{contentbox}{label=Agregar y eliminar información}
%     \begin{tabular}{C|p{0.45\linewidth}}
%         \lstinline!df[Nombre] = Datos! & Agrega al final la columna \lstinline!Nombre! con los datos \lstinline!Datos!. \\
%         \lstinline!df.insert(n, N, D)! & Agrega la columna \lstinline!N! con los datos \lstinline!D! en la posición \lstinline!n!. \\
%         \lstinline!df.drop(Ns, axis=x)! & Elimina las filas (\lstinline!x=0!) o columnas (\lstinline!x=1!) cuyos nombres estén en (\lstinline!Ns!). \\
%     \end{tabular}
    
%     \vspace{\baselineskip}
%     Para unir dos \lstinline!DataFrames! se puede utilizar la instrucción:
%     \begin{center}
%         \lstinline!new_df = pd.concat([df_1, df_2], axis=x)!    
%     \end{center}
    
%     donde el orden de los \lstinline!DataFrame! determina el orden en que aparecen los datos en el nuevo \lstinline!DataFrame! y el valor de \lstinline!axis! determina si la unión se hace uno sobre otro (0) o uno al lado del otro (1).
    
%     Si la unión se hace lateral, los datos se ordenarán haciendo coincidir sus índices; en caso de que algunas filas no tengan los mismo índices, se generan filas con la información del \lstinline!DataFrame! original, rellenando con valores \lstinline!NaN!.
    
%     En el caso de uniones verticales el parámetro opcional \lstinline!ignore_index! (\lstinline!False!, por defecto), al asignarle \lstinline!True!, permite resetear los índices.
% \end{contentbox}

% \begin{contentbox}{label=Exportación de Archivos}
%     Los \texttt{DataFrame} pueden ser exportados a \textsc{csv} u hoja de cálculo con las siguientes funciones:
%     \begin{lstlisting}
% df.to_csv(fichero.csv,
%           sep=",",
%           header=True,
%           index=True,
%           decimal=".")
% df.to_csv(fichero.csv,
%           sheet_name="Sheet1",
%           header=True,
%           index=True)
%     \end{lstlisting}
%     donde los valores por defecto de los parámetros son los dados. Los parámetros \texttt{header} e \texttt{index} señalan si se incluyen los nombres de columnas y filas, respectivamente, en el archivo de salida.
% \end{contentbox}

% \begin{contentbox}{label=Agregación}
%     Son \alert{funciones de agregación} aquellas que convierten varios valores en uno solo. Las siguientes funciones generan un valor, si se ejecutan sobre una columna, o una \texttt{Series}, si se ejecutan sobre varias, cuyos índices son las columnas y los valores, el resultado por columna:
    
%     \begin{tabular}{C|p{0.6\linewidth}}
%         \lstinline!df.count()! & Cuenta celdas no vacías \\
%         \lstinline!df.max()! &  El máximo de los valores \\
%         \lstinline!df.min()! & El mínimo de los valores \\
%         \lstinline!df.idxmax()! &  El índice del máximo de los valores \\
%         \lstinline!df.idxmin()! & El índice del mínimo de los valores \\
%         \lstinline!df.sum()! & La suma de los valores de las celdas
%     \end{tabular}
% \end{contentbox}

% \begin{contentbox}{label=Operaciones vectoriales de string}
%     Una \texttt{Series} (y, por ende, una columna de un \texttt{DataFrame}) contiene el atributo \texttt{str}, que permite acceder a todas las funciones de string habituales, pero aplicadas a cada elemento de la serie. Esto incluye algunas funciones adicionales, para emular algunos operadores:
    
%     \begin{tabular}{C|p{0.35\linewidth}}
%         \lstinline!df["c"].str.contains(text)! & Verifica si \texttt{text} está en cada celda. \\
%         \lstinline!df["c"].str.get(i)! &  Retorna el caracter en la posición \texttt{i} de cada celda.
%     \end{tabular}
% \end{contentbox}

\end{multicols*}
\end{document}
